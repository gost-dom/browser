package configuration

// ESMethodWrapper contains information about how to generate ES wrapper code
// around a single class method.
type ESMethodWrapper struct {
	// When set, the ES wrapper will generate an error with the message, "Not implemented"
	NotImplemented bool
	// When set, nothing will be generated for the member
	Ignored bool
	// CustomImplementation tells that the wrapper code will be generated by hand.
	// Code generator will still install a function on the prototype template
	// referencing the custom function
	CustomImplementation bool
	Arguments            map[string]*ESMethodArgument
	// Name of the method that will convert the result to JS
	Encoder string
}

func (w *ESMethodWrapper) SetEncoder(e string) *ESMethodWrapper {
	w.Encoder = e
	return w
}

// SetNotImplemented is a simple wrapper around [NotImplemented] to support a
// chaning DSL syntax.
func (w *ESMethodWrapper) SetNotImplemented() *ESMethodWrapper {
	w.NotImplemented = true
	return w
}

func (w *ESMethodWrapper) Ignore() *ESMethodWrapper {
	w.Ignored = true
	return w
}

func (w *ESMethodWrapper) SetCustomImplementation() *ESMethodWrapper {
	w.CustomImplementation = true
	return w
}

func (w *ESMethodWrapper) ensureMap() {
	if w.Arguments == nil {
		w.Arguments = make(map[string]*ESMethodArgument)
	}
}

func (w *ESMethodWrapper) Argument(name string) (result *ESMethodArgument) {
	w.ensureMap()
	var ok bool
	if result, ok = w.Arguments[name]; !ok {
		result = new(ESMethodArgument)
		w.Arguments[name] = result
	}
	return result
}
